## 抢红包

[TOC]

## 问题

1. 在游戏中，玩家A向全服玩家发送红包，其他玩家可以通过“抢红包”的操作来获得红包中的部分奖励，每个红包会被10个玩家瓜分。

2. 尝试思考，当有1000名玩家几乎同时发起“抢红包”操作时，如何保证每个玩家的操作延时在 10ms以下？

## 红包随机算法思路

### 随机分配红包剩余金额

最简单的随机实现方法，玩家每次打开红包都会随机分配红包剩余的金额。

![剩余金额随机分配](http://cdn.lentme.cn/20221216222519.png)

> 剩余金额随机分配很容易导致前几个抢到红包的用户就是收起最佳的，而后续的用户打开红包甚至只能拿到"低保"金额，故需改进

### 二倍均值法

二倍均值法理论上保证了每次拆红包时所获得的金额范围都是相等的，而不会因为拆包的先后顺序而导致随机范围越来越小。

![二倍均值法](http://cdn.lentme.cn/20221216224607.png)

#### 二倍均值法实现关键代码

```c++
// 随机数生成引擎
random_device rd{};
mt19937 engine{rd()};
// 随机数分布范围
uniform_real_distribution<double> dist{0.0, 1.0};
// 取随机数
double random_number_between_0_and_1 = dist(engine);
// 保底0.01
double cal = 0.01 + ceil(100 * (random_number_between_0_and_1 * (2 * (remain_money / remain_num) - 0.01))) / 100;
```

## 发抢红包流程思路

### 基本流程

![基本流程](http://cdn.lentme.cn/20221217234910.png)

### 单线程简单发派模拟

核心代码: 

```c++
// 剩余金额
double remain_money = money;
// 分发人数
int num = diliver_num;
// 模拟抢红包
for(int i = num; i > 0; i--) {
  double money = std::calculate_one_paper_by_double_mean(remain_money, i);
  remain_money -= money;
  printf("play[%02d]抢到红包[%.2lf]\n", i, money);
}
```

> 该段代码直观地展现了流程图的基本思路实现，但该程序简化了实际上的各种复杂环境，尤其是在性能模拟以及在高并发的情况下如何发派等情况上并不能够模拟实际的流程，故需在此基础上继续实现。

### 多线程的并发模拟

核心代码：

```c++
// 红包对象
RedPaper rp(money, num);
for(int i = 1000; i > 0; i--) {
  // 新建线程去执行抢红包的动作(grab)
  std::thread t(&RedPaper::grab, &rp);
}
```

![多线程结果](http://cdn.lentme.cn/20221218001402.png)

> 多线程相较于单线程能够模拟到服务器接受多个用户并发的抢红包请求，但由于这段程序的模拟中，对每一个用户的请求都会新建一个线程去处理，结果是：
> 
> 每次抢红包的操作(grab)都不超过2ms，而循环新建线程的时间却占用了几十毫秒，假设所有请求几乎都是同时到达，那么最后一个被处理的请求可能就需要等待几十毫秒才能执行抢红包的逻辑。
>
> 故需要在线程的问题上进一步优化

### 线程池的并发模拟

核心代码:

```c++
// 线程池中预设8个工作线程
ThreadPool pool(8);
pool.init();

// 模拟路由1000次请求
for(int i = 1000; i > 0; i--) {
  // 往线程池提交抢红包的操作
  auto f = pool.submit(func_grab);
}
```

![线程池模拟](http://cdn.lentme.cn/20221218003326.png)

## 高并发策略优化

### 协程与线程池

通过上述的实验可以验证线程池相较于重复新建线程更为高效，但在实际应用中，线程池往往会因为时间片的耗尽而导致触发上下文的切换。

当一个线程持有抢红包的唯一锁且未完成金额分配时恰好时间片耗尽而切换上下文，最差的情况下会导致线程池内所有线程空转了一圈而消耗了相应的时间。

第二种情况则是假设用户存在一些其他的IO操作或者锁竞争时，则会有一部分包括时间在内的的资源开销，这也是线程池无法避免的地方。

综上，若能够控制当前所执行的任务在合适的时候主动让出CPU运算资源，可能可以更好的去优化高并发的接待能力。

#### QPS验证

在单机四核的Linux上进行QPS验证：

1. 基于线程池方案的web服务器：

![线程池服务器](http://cdn.lentme.cn/20221218013736.png)

2. 基于协程方案的web服务器

![协程服务器](http://cdn.lentme.cn/20221218015027.png)

> 可见在高并发的情况下，协程一定程度上接待能力优于线程池


### 并发模型下数据的缓存

在玩家瓜分红包时，在高并发方面上优化时延的同时，数据一致性更为重要。要同时保证高并发的能力和数据一致性，则需在程序持久化之前加上一层高速缓存策略。

目前主流采用redis缓存，但要求不使用中间件的情况下，则可采用内存映射的形式进行缓存。

采用内存映射可以实现线程、进程间的交互。可以考虑封装内存映射成基于`key-value`形式进行操作，而降低代码的编程复杂程度，提高程序代码的阅读性和健壮性。

### 基于长连接的优化方案

一个玩家能够向全服玩家发送红包，并让各位玩家瓜分，则需要服务器有主动推送消息给游戏客户端的能力，则离不开TCP长连接的支持。

则在基于长连接的即时消息推送的方案上，可以在通信协议上进行优化，从而实现在信息量不变的情况下减少IO的数据量，则可以一定程度上减少玩家操作的延时。

## 总结

上文所讨论的优化方案，主要有以下几点:

1. 线程池替代重复创建线程，提高接待能力

2. 协程的可能性

3. 高并发的情况下数据需要在内存中缓存

4. TCP长连接协议优化

理论上主要围绕着资源复用、IO优化、并发资源竞争三个方面进行讨论，部分方案还需要具体验证还需要继续设计并编码测试，同时也需要整合起来进行一些必要的调试。
